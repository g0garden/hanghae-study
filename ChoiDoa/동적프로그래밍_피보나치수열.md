## 피보나치 수열

**피보나치 수열, 대표적인 동적 프로그래밍의 사례이다.
자기 자신은 자신과 닮은 자기보다 작은 것들로 구성!**

- 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 …
- 기준 수보다 **앞에 있는 수**와 **두 칸 앞에 있는 수**를 더한 것과 같다.
- 즉, 첫 번째 항의 값과 두 번째 항의 값 이후인 다음 항은 이전 두 항을 더한 값으로 이루어지는 수열이다.

## 점화식

**f(n) = f(n - 1) + f(n - 2) 
즉, f(1) = f(2) = 1**

- 즉, 작은 문제들을 합쳐서 큰 문제들을 만드는 것
- 첫 번째 피보나치 수열과 두 번째 피보나치 수열은 모두 1의 값을 가진다.

## 동적 프로그래밍 (DP = 동적 계획법)

**작은 문제들을 합쳐서 큰 문제를 만드는 것**

## '동적 프로그래밍' 이 뭐야 ?

- 하나의 문제는 **단 한 번만 풀도록 하는 알고리즘**이다.
- 한 번 푼 문제를 여러번에 걸쳐 다시 푸는 비효율적인 알고리즘을 개선하는 방법

## 아하‼️ 그럼 분할 정복 알고리즘과 차이는 ?

> 분할 정복 알고리즘은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 다만, 분할 정복 알고리즘은 정렬과 같은 요소에서는 동일한 문제를 다시 풀게 되는 단점은 없으므로 참고!

## 재귀를 이용한 피보나치

**최솟값 1 부터 최댓값 10 의 피보나치를 구해보자!**

```python
# 재귀를 이용한 피보나치
def fibonacci(N):
    if N <= 1:
        return N
    else:
        return(fibonacci(N-1) + fibonacci(N-2))

for i in range(1, 10):
    print(fibonacci(i))
```

→ **여기서!**

- 위와 같이 재귀적 형태로 문제를 해결하게 되면, 굉장히 오랜 시간이 소요되기 때문에 답을 구하는데 굉장히 오랜 시간이 소요된다.
- 예로들어보자, 위 코드는 10 까지의 수를 구하는 프로그램이지만 만일 구하려는 **범위가 100 까지라면** ..? 위 코드에서 연산되는 횟수는 2^n 이다.ㅎㅎ

## 동적 프로그래밍을 이용한다면!

> 작은 문제에서 구한 정답을 **배열**에 담아, 불필요한 연산을 다시 반복할 필요 없이 연산이 필요한 값을 꺼내와 사용한다. 쉽게 말해 크고 어려운 문제가 있다면 그것을 잘게 나누어서 해결해놓고 필요할 때 전체의 답을 구한다.

## 동적 프로그래밍을 이용하는 방법?
메모이제이션!

이미 계산한 결과는 배열에 저장한다는 것
추후에 동일한 계산을 할 때에는 저장된 값만을 반환하면 된다.
이러한 특성으로 실행 속도 또한 향상된다.

## 동적 프로그래밍을 이용한 피보나치

**배열을 미리 만들어, 해당 값을 리스트에 저장한다!**

```python
fibonacci = []
for i in range(0, 10):
    if i < 2:
        fibonacci.append(1)
    else:
        fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2])

print(fibonacci)
```
